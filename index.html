<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cardiac Ion Movement Simulator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    // Physiologic phase definitions
    const PHASES = {
      nodal: [
        {
          key: "pacemaker",
          label: "Pacemaker potential",
          graph: { start: 0.0, end: 0.45 },
          open: ["Na_slow"],
          closing: ["K"],
          flux: [
            { ion: "Na", dir: "in", strength: "slow" },
            { ion: "K", dir: "out", strength: "decreasing" },
          ],
          explain: "Slow Na⁺ channels open; K⁺ channels are closing → slow depolarizing drift toward threshold.",
        },
        {
          key: "depol",
          label: "Depolarization",
          graph: { start: 0.45, end: 0.65 },
          open: ["Ca_fast"],
          closing: [],
          flux: [{ ion: "Ca", dir: "in", strength: "fast" }],
          explain: "Fast Ca²⁺ channels open → Ca²⁺ influx creates the upstroke.",
        },
        {
          key: "repol",
          label: "Repolarization",
          graph: { start: 0.65, end: 1.0 },
          open: ["K"],
          closing: ["Ca_fast"],
          flux: [{ ion: "K", dir: "out", strength: "fast" }],
          explain: "Ca²⁺ channels close; K⁺ channels open → K⁺ efflux repolarizes the cell.",
        },
      ],
      contractile: [
        {
          key: "depol",
          label: "Depolarization (Phase 0)",
          graph: { start: 0.0, end: 0.18 },
          open: ["Na_fast"],
          closing: [],
          flux: [{ ion: "Na", dir: "in", strength: "fast" }],
          explain: "Fast Na⁺ channels open → rapid Na⁺ influx (steep spike).",
        },
        {
          key: "plateau",
          label: "Plateau (Phase 2)",
          graph: { start: 0.18, end: 0.70 },
          open: ["Ca"],
          closing: [],
          flux: [
            { ion: "Ca", dir: "in", strength: "medium" },
            { ion: "K", dir: "out", strength: "medium" },
          ],
          explain: "Ca²⁺ channels open → Ca²⁺ influx balanced by K⁺ efflux → sustained plateau.",
        },
        {
          key: "repol",
          label: "Repolarization (Phase 3)",
          graph: { start: 0.70, end: 1.0 },
          open: ["K"],
          closing: ["Ca"],
          flux: [{ ion: "K", dir: "out", strength: "fast" }],
          explain: "Ca²⁺ inactivates; K⁺ channels open → K⁺ efflux returns to rest.",
        },
      ],
    };

    const apCurve = (cellType, x) => {
      if (cellType === "nodal") {
        if (x < 0.45) return 0.15 + 0.4 * (x / 0.45);
        if (x < 0.65) return 0.55 + 0.45 * ((x - 0.45) / 0.20);
        return 1.0 - 0.85 * ((x - 0.65) / 0.35);
      }
      if (x < 0.10) return 0.1 + 0.9 * (x / 0.10);
      if (x < 0.70) return 0.95 - 0.15 * ((x - 0.10) / 0.60);
      return 0.80 - 0.70 * ((x - 0.70) / 0.30);
    };

    const ION_COUNTS = { Na: 20, K: 15, Ca: 15 };
    const ION_COLORS = { Na: "#2563eb", K: "#7c3aed", Ca: "#16a34a" };

    function makeParticles(width, height) {
      const particles = [];
      const topY = height * 0.20;
      const botY = height * 0.70;
      const add = (ion, count) => {
        for (let i = 0; i < count; i++) {
          const inTop = Math.random() < 0.5;
          particles.push({
            id: `${ion}-${i}-${Math.random().toString(36).slice(2)}`,
            ion,
            x: Math.random() * width,
            y: inTop ? topY + Math.random() * (height * 0.18) : botY + Math.random() * (height * 0.18),
            vx: (Math.random() - 0.5) * 0.4,
            vy: (Math.random() - 0.5) * 0.4,
            compartment: inTop ? "out" : "in",
            cooldown: 0,
          });
        }
      };
      add("Na", ION_COUNTS.Na);
      add("K", ION_COUNTS.K);
      add("Ca", ION_COUNTS.Ca);
      return particles;
    }

    function strengthToSpeed(strength) {
      switch (strength) {
        case "slow": return 0.6;
        case "medium": return 1.4;
        case "fast": return 2.8;
        case "decreasing": return 0.3;
        default: return 1.0;
      }
    }

    const CHANNELS = [
      { key: "Na_slow", label: "Slow Na⁺", x: 0.25 },
      { key: "Na_fast", label: "Fast Na⁺", x: 0.35 },
      { key: "Ca_fast", label: "Fast Ca²⁺", x: 0.55 },
      { key: "Ca", label: "Ca²⁺", x: 0.55 },
      { key: "K", label: "K⁺", x: 0.75 },
    ];

    function ionForChannel(chKey) {
      if (chKey.startsWith("Na")) return "Na";
      if (chKey.startsWith("Ca")) return "Ca";
      return "K";
    }

    function HeartChooser({ onChoose }) {
      return (
        <div className="min-h-screen w-full flex items-center justify-center bg-slate-50 p-6">
          <div className="max-w-3xl w-full grid md:grid-cols-2 gap-6">
            <div className="bg-white rounded-2xl shadow p-6 flex flex-col gap-3">
              <h1 className="text-2xl font-semibold">Pick a cell type</h1>
              <p className="text-slate-600">Click to explore the action potential and ion movement.</p>
              <div className="mt-2 flex gap-3">
                <button onClick={() => onChoose("nodal")} className="px-4 py-2 rounded-xl bg-blue-600 text-white shadow hover:bg-blue-700">
                  Nodal (autorhythmic)
                </button>
                <button onClick={() => onChoose("contractile")} className="px-4 py-2 rounded-xl bg-emerald-600 text-white shadow hover:bg-emerald-700">
                  Contractile myocardium
                </button>
              </div>
            </div>
            <div className="bg-white rounded-2xl shadow p-6 flex items-center justify-center">
              <div className="w-full h-64 rounded-xl bg-gradient-to-br from-rose-100 to-rose-200 flex items-center justify-center text-rose-700 font-medium">
                Heart image placeholder
              </div>
            </div>
          </div>
        </div>
      );
    }

    function MiniGraph({ cellType, t }) {
      const w = 180, h = 120, pad = 12;
      const points = useMemo(() => {
        const arr = [];
        for (let i = 0; i <= 60; i++) {
          const x = i / 60;
          const y = apCurve(cellType, x);
          arr.push([x, y]);
        }
        return arr;
      }, [cellType]);
      const toSvgX = (x) => pad + x * (w - 2 * pad);
      const toSvgY = (y) => h - pad - y * (h - 2 * pad);
      const d = points.map(([x, y], i) => `${i ? "L" : "M"}${toSvgX(x)} ${toSvgY(y)}`).join(" ");
      const dotX = toSvgX(t);
      const dotY = toSvgY(apCurve(cellType, t));
      return (
        <svg width={w} height={h} className="bg-white rounded-xl shadow">
          <path d={d} fill="none" stroke="#111827" strokeWidth="2" />
          <circle cx={dotX} cy={dotY} r="4" fill="#ef4444" />
          <text x={pad} y={pad + 8} fontSize="10" fill="#374151">Vm</text>
        </svg>
      );
    }

    function IonCanvas({ cellType, phaseIndex, playing, speed, onTime }) {
      const canvasRef = useRef(null);
      const rafRef = useRef(null);
      const particlesRef = useRef([]);
      const tRef = useRef(PHASES[cellType][phaseIndex].graph.start);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        particlesRef.current = makeParticles(canvas.width, canvas.height);
        tRef.current = PHASES[cellType][phaseIndex].graph.start;
      }, [cellType]);

      useEffect(() => {
        tRef.current = PHASES[cellType][phaseIndex].graph.start;
      }, [cellType, phaseIndex]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        let last = performance.now();

        const tick = (now) => {
          const dt = (now - last) / 1000;
          last = now;
          const { width, height } = canvas;
          const membraneY = height * 0.5;
          const topBound = height * 0.05;
          const bottomBound = height * 0.95;
          const phase = PHASES[cellType][phaseIndex];
          const openChannels = phase.open;

          if (playing) {
            const end = phase.graph.end;
            const tNext = tRef.current + dt * 0.05 * speed;
            tRef.current = tNext >= end ? end : tNext;
            onTime?.(tRef.current);
          }

          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = "#64748b";
          ctx.font = "12px sans-serif";
          ctx.fillText("Extracellular (outside)", 10, 20);
          ctx.fillText("Intracellular (inside)", 10, height - 10);

          ctx.fillStyle = "#0f172a";
          ctx.fillRect(0, membraneY - 6, width, 12);
          ctx.fillStyle = "#334155";
          ctx.fillRect(0, membraneY - 2, width, 4);

          CHANNELS.forEach((ch) => {
            const cx = ch.x * width;
            const isOpen = openChannels.includes(ch.key);
            ctx.fillStyle = isOpen ? "#f59e0b" : "#64748b";
            ctx.fillRect(cx - 10, membraneY - 18, 20, 36);
            ctx.save();
            ctx.translate(cx, membraneY - 18);
            ctx.strokeStyle = "#111827";
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (isOpen) {
              ctx.moveTo(0, 0);
              ctx.lineTo(-14, -10);
            } else {
              ctx.moveTo(-10, 0);
              ctx.lineTo(10, 0);
            }
            ctx.stroke();
            ctx.restore();
            ctx.fillStyle = "#111827";
            ctx.font = "10px sans-serif";
            ctx.fillText(ch.label, cx - 18, membraneY + 30);
          });

          const particles = particlesRef.current;
          for (const p of particles) {
            p.vx += (Math.random() - 0.5) * 0.05;
            p.vy += (Math.random() - 0.5) * 0.05;
            p.vx *= 0.97;
            p.vy *= 0.97;
            p.cooldown = Math.max(0, p.cooldown - dt);

            const targetKey = openChannels.find((k) => ionForChannel(k) === p.ion);
            if (targetKey) {
              const ch = CHANNELS.find((c) => c.key === targetKey);
              if (ch) {
                const tx = ch.x * width;
                const ty = membraneY;
                const dx = tx - p.x;
                const dy = ty - p.y;
                const dist = Math.hypot(dx, dy) + 0.001;
                const flux = phase.flux.find((f) => f.ion === p.ion);
                const accel = strengthToSpeed(flux?.strength || "medium") * 0.6;
                p.vx += (dx / dist) * accel * dt;
                p.vy += (dy / dist) * accel * dt;

                const inMouth = Math.abs(p.y - membraneY) < 8 && Math.abs(p.x - tx) < 12 && p.cooldown === 0;
                if (inMouth) {
                  if (flux?.dir === "in" && p.compartment === "out") {
                    p.compartment = "in";
                    p.y = membraneY + 22;
                    p.vy += 3.5;
                    p.cooldown = 0.6;
                  }
                  if (flux?.dir === "out" && p.compartment === "in") {
                    p.compartment = "out";
                    p.y = membraneY - 22;
                    p.vy -= 3.5;
                    p.cooldown = 0.6;
                  }
                }
              }
            }

            p.x += p.vx;
            p.y += p.vy;
            if (p.x < -10) p.x = width + 10;
            if (p.x > width + 10) p.x = -10;
            if (p.y < topBound) p.y = topBound;
            if (p.y > bottomBound) p.y = bottomBound;

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.fillStyle = ION_COLORS[p.ion];
            ctx.strokeStyle = "#111827";
            ctx.lineWidth = 1;
            if (p.ion === "Na") {
              ctx.beginPath();
              ctx.rect(-4.5, -4.5, 9, 9);
              ctx.fill();
              ctx.stroke();
            } else if (p.ion === "K") {
              ctx.beginPath();
              ctx.moveTo(0, -5);
              ctx.lineTo(5, 5);
              ctx.lineTo(-5, 5);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            } else {
              ctx.beginPath();
              ctx.arc(0, 0, 4.5, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            }
            ctx.restore();
          }
          rafRef.current = requestAnimationFrame(tick);
        };
        rafRef.current = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(rafRef.current);
      }, [cellType, phaseIndex, playing, speed, onTime]);

      return <canvas ref={canvasRef} width={700} height={420} className="w-full rounded-2xl bg-slate-100 shadow-inner" />;
    }

    function Legend() {
      return (
        <div className="flex flex-wrap items-center gap-4 text-sm text-slate-700 bg-white rounded-xl shadow px-4 py-2">
          <div className="flex items-center gap-2">
            <span className="inline-block w-4 h-4 bg-blue-600 border border-slate-900" />
            <span>Na⁺ = square</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="inline-block w-0 h-0 border-l-8 border-r-8 border-b-[14px] border-l-transparent border-r-transparent border-b-purple-600" />
            <span>K⁺ = triangle</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="inline-block w-4 h-4 rounded-full bg-emerald-600 border border-slate-900" />
            <span>Ca²⁺ = circle</span>
          </div>
          <div className="ml-auto text-xs text-slate-500">Top = extracellular | Bottom = intracellular</div>
        </div>
      );
    }

    function ModuleScreen({ cellType, onBack }) {
      const [phaseIndex, setPhaseIndex] = useState(0);
      const [playing, setPlaying] = useState(false);
      const [speed, setSpeed] = useState(1);
      const [t, setT] = useState(PHASES[cellType][0].graph.start);
      const phases = PHASES[cellType];
      const phase = phases[phaseIndex];

      return (
        <div className="min-h-screen w-full bg-slate-50 p-4 md:p-8">
          <div className="max-w-6xl mx-auto flex flex-col gap-4">
            <header className="flex items-center justify-between flex-wrap gap-4">
              <div className="flex items-center gap-3">
                <button onClick={onBack} className="px-3 py-1.5 rounded-lg bg-white shadow hover:bg-slate-100">← Heart</button>
                <h2 className="text-2xl font-semibold">{cellType === "nodal" ? "Autorhythmic (Nodal) Cell" : "Contractile Muscle Cell"}</h2>
              </div>
              <MiniGraph cellType={cellType} t={t} />
            </header>
            <IonCanvas cellType={cellType} phaseIndex={phaseIndex} playing={playing} speed={speed} onTime={setT} />
            <Legend />
            <div className="bg-white rounded-2xl shadow p-4 md:p-6 flex flex-col gap-3">
              <div className="flex flex-wrap items-center gap-2">
                {phases.map((p, i) => (
                  <button key={p.key + i} onClick={() => setPhaseIndex(i)} className={`px-3 py-1.5 rounded-lg text-sm shadow ${i === phaseIndex ? "bg-amber-500 text-white" : "bg-slate-100 hover:bg-slate-200"}`}>
                    {p.label}
                  </button>
                ))}
              </div>
              <div className="flex flex-wrap items-center gap-2 mt-1">
                <button onClick={() => setPhaseIndex(i => Math.max(i - 1, 0))} className="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200 shadow">Prev</button>
                <button onClick={() => setPlaying(v => !v)} className="px-3 py-1.5 rounded-lg bg-blue-600 text-white hover:bg-blue-700 shadow">{playing ? "Pause" : "Play"}</button>
                <button onClick={() => setPhaseIndex(i => Math.min(i + 1, phases.length - 1))} className="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200 shadow">Next</button>
                <div className="ml-auto flex items-center gap-2">
                  <label className="text-sm text-slate-600">Speed</label>
                  <input type="range" min={0.5} max={3} step={0.1} value={speed} onChange={(e) => setSpeed(Number(e.target.value))} />
                  <span className="text-sm w-8 text-slate-700">{speed.toFixed(1)}×</span>
                </div>
              </div>
              <div className="mt-2 grid md:grid-cols-3 gap-3 items-start">
                <div className="md:col-span-2">
                  <h3 className="font-semibold">What's happening in this phase</h3>
                  <p className="text-slate-700 mt-1">{phase.explain}</p>
                </div>
                <div className="bg-slate-50 rounded-xl p-3">
                  <h4 className="text-sm font-semibold mb-1">Channels open</h4>
                  <ul className="text-sm text-slate-700 list-disc ml-4">
                    {phase.open.length ? phase.open.map((c) => <li key={c}>{c}</li>) : <li>None</li>}
                  </ul>
                  {!!phase.closing.length && (
                    <>
                      <h4 className="text-sm font-semibold mt-2 mb-1">Channels closing</h4>
                      <ul className="text-sm text-slate-700 list-disc ml-4">{phase.closing.map((c) => <li key={c}>{c}</li>)}</ul>
                    </>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function App() {
      const [cellType, setCellType] = useState(null);
      if (!cellType) return <HeartChooser onChoose={setCellType} />;
      return <ModuleScreen cellType={cellType} onBack={() => setCellType(null)} />;
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
